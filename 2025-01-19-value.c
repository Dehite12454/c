#include <stdio.h>
int main(){
    int a = 3; //변수 이름은 알파벳 숫자의 조함으로 작명하고 _을 통해 띄어쓰기를 구별한다.
    float b = 3.141592f;
    printf("a : %.2f\n", b); //소수점 둘째 자리로 반올림 하여라
    printf("b : %6.3f\n",b); //숫자의 자리수를 6자리로 맞추고 소수점 셋째 자리로 반올림 하여라


    int c = 10;
    int d = 3;
    double e = 3.0;
    printf("10/3 = %d\n",c/d); //int int 계산은 int 가 나온다.
    printf("10/3 = %f\n",c/e);    //int double 계산은 double 값이 나온다.

    int f = 0xAF;
    printf("%x\n",~f); // int 형 변수는 4 바이트이므로 역을 계산하면 4바이트 크기를 전부 역을 취해야 한다.

    int h = 2147483647; // int 가 표현할 수 있는 수는 -2147483648 부터 2147483647까지이다.
    printf("h : %d\n", h);
    printf("h : %d\n", h+1);    
    /* 
    2의 보수 표현법에 의해서 -로 변경되었다. 0011에 1101을 더하면 10000이 되므로, 앞의 1 은 잘라지고 0000이 된다.
    따라서 1101은 0011의 음수 표현이라고 말할 수 있다.
    맨 앞의 숫자가 1 이면 음수 0이면 양수이다. 즉 4bit 자료형은 0111:7부터 1001:-7까지 표현가능하다.
    여기서 중요한 점은 1000인데 이는 1000의 보수이다. 따라서 이를 -8로 놓는다.

    int 자료형 즉 32비트 자료형에서 최대값 2147483647 + 1 을 하게 되면 앞자리가 1로 바뀌며 음수로 변환된다.
    이를 오버 플로우라고 한다.

    undigned int는 음수값이 없는 32비트 자료형이다.
    0에서 4294967295까지 표현 가능하다.

    -1을 대입하면 어떤일이 벌어질까?
    1의 보수이므로 0xffffffff로 표현이 되므로 이를 그대로 나타낸 4294967295이 출력된다.

    그렇다면 4294967295 + 1 을 대입하면,
    0xffffffff + 1이므로 0이 출력되는 오버플로우가 일어나게 된다.
    */
    return 0;
}